#include "UnityPrefix.h"
#include "FloatConversion.h"

#define USE_STATIC_PRECOMPUTED_BYTE_TO_HALF_TABLES 1

FloatToHalfConverter::ExponentData FloatToHalfConverter::m_ExponentTable[256];

void FloatToHalfConverter::InitializePrecomputeTables()
{
    for (int i = 0; i < 256; i++)
    {
        int e = i - 127;
        int mantissaShift;
        // data in m_ExponentTable[i] is shifted left by 1 for rounding
        if (e < -25) // e=-25 may be rounded up, thus handle it as denormal number
        {
            // Too small to represent becomes zero
            m_ExponentTable[i].mask = 0x0000;
            // shift by one more than needed to clear mantissa, so that rounding
            // does not affect it
            mantissaShift = 25;
        }
        else if (e < -14)
        {
            // Small numbers become denormals
            m_ExponentTable[i].mask = 0x0400 >> (-14 - e - 1);
            mantissaShift = -1 - e; // mantissaShift is in range 14 .. 24
        }
        else if (e < 16)
        {
            // Handle normalized numbers
            m_ExponentTable[i].mask = (15 + e) << 10 << 1;
            mantissaShift = 13;
        }
        else if (e < 128)
        {
            // Large numbers become infinity
            m_ExponentTable[i].mask = 0x7C00 << 1;
            // Shift by one more than needed to clear mantissa, so that rounding
            // does not affect it
            mantissaShift = 25;
        }
        else
        {
            // Handle infinity and NaN
            m_ExponentTable[i].mask = 0x7C00 << 1;
            mantissaShift = 13;
        }
        m_ExponentTable[i].shiftMinus1 = mantissaShift - 1;
    }
}

FloatToHalfConverter g_FloatToHalf;

static void InitializeHalfConversionTables(void*)
{
    FloatToHalfConverter::InitializePrecomputeTables();

#if !USE_STATIC_PRECOMPUTED_BYTE_TO_HALF_TABLES
    for (int i = 0; i < 256; i++)
        g_ByteToNormalizedHalf[i] = FloatToHalf(ByteToNormalized(static_cast<UInt8>(i)));

    for (int i = 0; i < 256; i++)
        g_SignedByteToNormalizedHalf[i] = FloatToHalf(SignedByteToNormalized(static_cast<SInt8>(i)));
#endif
}

struct InitHfcTables {
    InitHfcTables() { InitializeHalfConversionTables(nullptr); }
};
static InitHfcTables sInitHfcTables;

#if USE_STATIC_PRECOMPUTED_BYTE_TO_HALF_TABLES

// These tables are small enough, and the code to generate them non-trivial enough, that it may make sense to store them like this.
// Could make them const, but then the #define would have to go (or be moved to the header file).

UInt16 g_ByteToNormalizedHalf[] =
{
    0x0000, 0x1c04, 0x2004, 0x2206, 0x2404, 0x2505, 0x2606, 0x2707, 0x2804, 0x2885, 0x2905, 0x2986, 0x2a06, 0x2a87, 0x2b07, 0x2b88,
    0x2c04, 0x2c44, 0x2c85, 0x2cc5, 0x2d05, 0x2d45, 0x2d86, 0x2dc6, 0x2e06, 0x2e46, 0x2e87, 0x2ec7, 0x2f07, 0x2f47, 0x2f88, 0x2fc8,
    0x3004, 0x3024, 0x3044, 0x3064, 0x3085, 0x30a5, 0x30c5, 0x30e5, 0x3105, 0x3125, 0x3145, 0x3165, 0x3186, 0x31a6, 0x31c6, 0x31e6,
    0x3206, 0x3226, 0x3246, 0x3266, 0x3287, 0x32a7, 0x32c7, 0x32e7, 0x3307, 0x3327, 0x3347, 0x3367, 0x3388, 0x33a8, 0x33c8, 0x33e8,
    0x3404, 0x3414, 0x3424, 0x3434, 0x3444, 0x3454, 0x3464, 0x3474, 0x3485, 0x3495, 0x34a5, 0x34b5, 0x34c5, 0x34d5, 0x34e5, 0x34f5,
    0x3505, 0x3515, 0x3525, 0x3535, 0x3545, 0x3555, 0x3565, 0x3575, 0x3586, 0x3596, 0x35a6, 0x35b6, 0x35c6, 0x35d6, 0x35e6, 0x35f6,
    0x3606, 0x3616, 0x3626, 0x3636, 0x3646, 0x3656, 0x3666, 0x3676, 0x3687, 0x3697, 0x36a7, 0x36b7, 0x36c7, 0x36d7, 0x36e7, 0x36f7,
    0x3707, 0x3717, 0x3727, 0x3737, 0x3747, 0x3757, 0x3767, 0x3777, 0x3788, 0x3798, 0x37a8, 0x37b8, 0x37c8, 0x37d8, 0x37e8, 0x37f8,
    0x3804, 0x380c, 0x3814, 0x381c, 0x3824, 0x382c, 0x3834, 0x383c, 0x3844, 0x384c, 0x3854, 0x385c, 0x3864, 0x386c, 0x3874, 0x387c,
    0x3885, 0x388d, 0x3895, 0x389d, 0x38a5, 0x38ad, 0x38b5, 0x38bd, 0x38c5, 0x38cd, 0x38d5, 0x38dd, 0x38e5, 0x38ed, 0x38f5, 0x38fd,
    0x3905, 0x390d, 0x3915, 0x391d, 0x3925, 0x392d, 0x3935, 0x393d, 0x3945, 0x394d, 0x3955, 0x395d, 0x3965, 0x396d, 0x3975, 0x397d,
    0x3986, 0x398e, 0x3996, 0x399e, 0x39a6, 0x39ae, 0x39b6, 0x39be, 0x39c6, 0x39ce, 0x39d6, 0x39de, 0x39e6, 0x39ee, 0x39f6, 0x39fe,
    0x3a06, 0x3a0e, 0x3a16, 0x3a1e, 0x3a26, 0x3a2e, 0x3a36, 0x3a3e, 0x3a46, 0x3a4e, 0x3a56, 0x3a5e, 0x3a66, 0x3a6e, 0x3a76, 0x3a7e,
    0x3a87, 0x3a8f, 0x3a97, 0x3a9f, 0x3aa7, 0x3aaf, 0x3ab7, 0x3abf, 0x3ac7, 0x3acf, 0x3ad7, 0x3adf, 0x3ae7, 0x3aef, 0x3af7, 0x3aff,
    0x3b07, 0x3b0f, 0x3b17, 0x3b1f, 0x3b27, 0x3b2f, 0x3b37, 0x3b3f, 0x3b47, 0x3b4f, 0x3b57, 0x3b5f, 0x3b67, 0x3b6f, 0x3b77, 0x3b7f,
    0x3b88, 0x3b90, 0x3b98, 0x3ba0, 0x3ba8, 0x3bb0, 0x3bb8, 0x3bc0, 0x3bc8, 0x3bd0, 0x3bd8, 0x3be0, 0x3be8, 0x3bf0, 0x3bf8, 0x3c00
};
CompileTimeAssertArraySize(g_ByteToNormalizedHalf, 256);

UInt16 g_SignedByteToNormalizedHalf[256] =
{
    0x0000, 0x2008, 0x2408, 0x260c, 0x2808, 0x290a, 0x2a0c, 0x2b0e, 0x2c08, 0x2c89, 0x2d0a, 0x2d8b, 0x2e0c, 0x2e8d, 0x2f0e, 0x2f8f,
    0x3008, 0x3049, 0x3089, 0x30ca, 0x310a, 0x314b, 0x318b, 0x31cc, 0x320c, 0x324d, 0x328d, 0x32ce, 0x330e, 0x334f, 0x338f, 0x33d0,
    0x3408, 0x3428, 0x3449, 0x3469, 0x3489, 0x34a9, 0x34ca, 0x34ea, 0x350a, 0x352a, 0x354b, 0x356b, 0x358b, 0x35ab, 0x35cc, 0x35ec,
    0x360c, 0x362c, 0x364d, 0x366d, 0x368d, 0x36ad, 0x36ce, 0x36ee, 0x370e, 0x372e, 0x374f, 0x376f, 0x378f, 0x37af, 0x37d0, 0x37f0,
    0x3808, 0x3818, 0x3828, 0x3838, 0x3849, 0x3859, 0x3869, 0x3879, 0x3889, 0x3899, 0x38a9, 0x38b9, 0x38ca, 0x38da, 0x38ea, 0x38fa,
    0x390a, 0x391a, 0x392a, 0x393a, 0x394b, 0x395b, 0x396b, 0x397b, 0x398b, 0x399b, 0x39ab, 0x39bb, 0x39cc, 0x39dc, 0x39ec, 0x39fc,
    0x3a0c, 0x3a1c, 0x3a2c, 0x3a3c, 0x3a4d, 0x3a5d, 0x3a6d, 0x3a7d, 0x3a8d, 0x3a9d, 0x3aad, 0x3abd, 0x3ace, 0x3ade, 0x3aee, 0x3afe,
    0x3b0e, 0x3b1e, 0x3b2e, 0x3b3e, 0x3b4f, 0x3b5f, 0x3b6f, 0x3b7f, 0x3b8f, 0x3b9f, 0x3baf, 0x3bbf, 0x3bd0, 0x3be0, 0x3bf0, 0x3c00,
    0xbc08, 0xbc00, 0xbbf0, 0xbbe0, 0xbbd0, 0xbbbf, 0xbbaf, 0xbb9f, 0xbb8f, 0xbb7f, 0xbb6f, 0xbb5f, 0xbb4f, 0xbb3e, 0xbb2e, 0xbb1e,
    0xbb0e, 0xbafe, 0xbaee, 0xbade, 0xbace, 0xbabd, 0xbaad, 0xba9d, 0xba8d, 0xba7d, 0xba6d, 0xba5d, 0xba4d, 0xba3c, 0xba2c, 0xba1c,
    0xba0c, 0xb9fc, 0xb9ec, 0xb9dc, 0xb9cc, 0xb9bb, 0xb9ab, 0xb99b, 0xb98b, 0xb97b, 0xb96b, 0xb95b, 0xb94b, 0xb93a, 0xb92a, 0xb91a,
    0xb90a, 0xb8fa, 0xb8ea, 0xb8da, 0xb8ca, 0xb8b9, 0xb8a9, 0xb899, 0xb889, 0xb879, 0xb869, 0xb859, 0xb849, 0xb838, 0xb828, 0xb818,
    0xb808, 0xb7f0, 0xb7d0, 0xb7af, 0xb78f, 0xb76f, 0xb74f, 0xb72e, 0xb70e, 0xb6ee, 0xb6ce, 0xb6ad, 0xb68d, 0xb66d, 0xb64d, 0xb62c,
    0xb60c, 0xb5ec, 0xb5cc, 0xb5ab, 0xb58b, 0xb56b, 0xb54b, 0xb52a, 0xb50a, 0xb4ea, 0xb4ca, 0xb4a9, 0xb489, 0xb469, 0xb449, 0xb428,
    0xb408, 0xb3d0, 0xb38f, 0xb34f, 0xb30e, 0xb2ce, 0xb28d, 0xb24d, 0xb20c, 0xb1cc, 0xb18b, 0xb14b, 0xb10a, 0xb0ca, 0xb089, 0xb049,
    0xb008, 0xaf8f, 0xaf0e, 0xae8d, 0xae0c, 0xad8b, 0xad0a, 0xac89, 0xac08, 0xab0e, 0xaa0c, 0xa90a, 0xa808, 0xa60c, 0xa408, 0xa008
};
CompileTimeAssertArraySize(g_SignedByteToNormalizedHalf, 256);

#else

UInt16 g_ByteToNormalizedHalf[256];
UInt16 g_SignedByteToNormalizedHalf[256];

#endif
